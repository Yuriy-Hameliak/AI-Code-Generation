  # AI OPTIMIZATION

  ![App Screenshot](https://lh7-us.googleusercontent.com/N6_0mVLOh1Jn__JuSDTUjH8-Py_2GuMvibpFWJiiy6d2DZvtkEHIMoY-FOkP5alIKKW3sQpWxy9hTuppg2w9BAyJKDpNxzI-nkaPuDMStUbOyMRLshRMslgTZxLs4VbPEp8KtnrDj9YM-7VT8xl9uWXJ=w1200-h630-p-k-no-nu)
  Тут будуть розміщені розглянуті нами (не)оптимізовані проблеми.

  ## Ceasar encode\decode

  Це доволі проста та відома проблема, тому припускалося, що геміні швидко знайде їй рішення. Так і майже сталося. При оптимізації ШІ в першу чергу змінив докстрінги. Там він додав аргументи та результат, які приймає та відповідно повертає функція. Також він одразу додумався, що для декодингу можна використовувати енкод з від'ємним шифтом.
  Наступною важливою зміною стало те, що після кількох скеровуючих запитів, щодо умови задачі ШІ майже правильно розглянув еджкейст для вхідних даних.
  ~~~
  if not all(isinstance(x, (str, int)) for x in (message, key)):
      return None
  ~~~
  ШІ прекрасно ігнорував УСІ запити на виправлення цього моменту, навіть прямі, тож було прийнято рішення просто сказати йому, щоб він це розділив, що він врешті-решт зробив. Після цієї зміни код пройшов усі тесткейси.

  Зміни, які вніс ШІ в алгоритм полягали у узагальненні завдання для будь-яких літер використовуючи одну змінну base для задання в майбутньому правильних рамок. Далі алгоритм ідейно співпадає.

  При перевірці двох алгоритмів за виконанням одного спеціального випадку мільйон разів, а потім обчисленні середніх результатів, ми отримали таке:

  #### Old version:

  Average Compilation Time over `1000000` repetitions: `0.0001` seconds
  Average Memory Usage over `1000000` repetitions: `54.0257 MiB`

  #### New version:

  Average Compilation Time over `1000000` repetitions: `0.0001` seconds
  Average Memory Usage over `1000000` repetitions: `55.8065 MiB`



  #### Avarage results:

  `Version №2` is `1.712816548347473e-05` faster.

  `Version №1` is `1.7808238085937518` more memory efficient.

  ### Висновок:

  ШІ вдалося злегка оптимізувати код в плані швидкості, адже навіть після кількох повторних тестувань, в середньому він трішки швидший. В той же час стара версія ефективніше використовує пам'ять. Також покращилась читабельність коду, а як ми всі добре знаємо, `readability counts`.  

  ## Acronym

  Тут ШІ перевершив усі навіть найсміливіши припущення. Він вирішив, що йому не треба нічого робити самому, тому він фактично стягнув код з чужого репозиторію.

  [РЕПОЗИТОРІЙ](https://github.com/OlehPalka/First_semester_labs)

  Оскільки код пройшов усі тесткейси та був згенерований для нас самим ШІ, то було прийнято рішення його залишити. Тим паче, що ШІ сказав `"...but the modified version is generally better suited for creating acronyms..."`.
  Наводжу результати тестування (знову таки ж средні на мільйон):

  #### Old version:
  Average Compilation Time over `1000000` repetitions: `0.0000` seconds
  Average Memory Usage over `1000000` repetitions: `56.0761 MiB`

  #### New version:
  Average Compilation Time over `1000000` repetitions: `0.0000` seconds
  Average Memory Usage over `1000000` repetitions: `53.9083 MiB`

  #### Avarage results:
  `Version №1` is `7.040505409240726e-07` faster.

  `Version №2` is `2.167764343750001` more memory efficient.

  ### Висновок:

  ШІ вдалося злегка оптимізувати код в плані використання пам'яті, навіть таким унікальним способом, та швидкість виконання все ще краща у першого варіанту, в середньому він трішки швидший. Також злегка покращилась читабельність коду.
  Загалом найважливішим висновком є те, що якщо ви не хочете, щоб ваш код використовуваа ШІ, робіть репозиторії приватними. 